## 1. 实验目的

&emsp;&emsp;（1）熟练掌握RISC-V汇编语言，熟悉并理解RISC-V指令系统；

&emsp;&emsp;（2）了解程序在单周期RISC-V SoC中的运行过程；

&emsp;&emsp;（3）进一步熟悉RARS、Logisim等汇编和模拟仿真工具的使用。



## 2. 实验内容 (for miniRV)

### 题目1：基本输入输出

&emsp;&emsp;在提供的Logisim SoC电路中，运行示例程序<font color = blue>**Exercise1.asm**</font>，并阅读该程序源码，分析程序功能，学习汇编程序访问I/O接口及外设的方法。

&emsp;&emsp;SoC电路具有数码管、LED、拨码开关3个外设，其I/O接口地址如表1-1所示。

<center>表1-1 数码管、LED、拨码开关端口地址</center>
<center>

| 外设 | I/O接口地址 |
| :-: | :-: |
| 数码管 | 0xFFFF_F000 |
| LED | 0xFFFF_F060 |
| 拨码开关 | 0xFFFF_F070 |
<!-- | 计时器 | 0xFFFF_F020 | -->

</center>

&emsp;&emsp;根据实验步骤运行程序，熟悉Logisim工具及操作流程。

### 题目2：简易计算器设计

&emsp;&emsp;运用miniRV指令集，编写简易计算器程序。

!!! danger "注意 :bomb:"
    &emsp;&emsp;计算器程序最终需要下板运行和演示，因此 **不要使用你不准备实现的指令**。比如，后续设计CPU时如果不实现附加的13条指令，则编写本题目的汇编程序时，只使用<a href="../1-step_rv/#21-risc-v-soc" target=_blank>实验步骤 - 2.1节 - 表2-1</a>所示的24条必做指令。

&emsp;&emsp;计算器的运算符和操作数A、B均通过拨码开关输入，如表1-2所示。

<center>表1-2 8位简易计算器的拨码开关输入定义</center>
<center>

| 拨码开关 | SW[23:21] | SW[20:16] | SW[15:8] | SW[7:0] |
| :-: | :-: | :-: | :-: | :-: |
| 输入功能 | 运算符 | 保留 | 操作数A | 操作数B |

</center>

&emsp;&emsp;计算器的运算结果需显示到数码管DK7~DK0。具体地，计算器的功能如表1-3所示。

<center>表1-3 运算器功能定义</center>
<center>

| SW[23:21] | 运算类型 | 数码管显示内容 | 说明 |
| :-: | :-: | :-: | :-: |
| 3'b000 | 无 | `32'h0000_0000` | - |
| 3'b001 | A + B | 高4位以10进制显示整数部分，<br>低4位以10进制显示小数部分 | 若整数部分大于15，按实际值显示 |
| 3'b010 | \|A - B\| | 高4位以10进制显示整数部分，<br>低4位以10进制显示小数部分 | - |
| 3'b011 | A $\times$ 2^B^ | 高4位以10进制显示整数部分，<br>低4位以10进制显示小数部分 | 若整数部分大于15，按实际值显示<br>此功能可通过移位运算实现 |
| 3'b100 | A $\div$ 2^B^ | 高4位以10进制显示整数部分，<br>低4位以10进制显示小数部分 | 此功能可通过移位运算实现 |
| 3'b101 | 生成随机数 | 以16进制显示32位随机数 | 以`{A,B,A,B}`为种子生成32位随机数<br>且每隔约1s生成一个新的随机数 |

</center>

&emsp;&emsp;计算加减法时，将输入的操作数A、B视为 ==无符号小数==，且高4位看作整数部分、低4位看作小数部分。比如，假设输入操作数A为`8'b1011_0101`，则表示数字`11.5`。**不考虑输入数据的小数部分大于9的情况**。

&emsp;&emsp;计算乘除法时，将输入的操作数A视为无符号小数，将操作数B视为整数。

&emsp;&emsp;要求除了生成随机数之外，其余运算的 ==**运算结果应以10进制显示**==。

!!! example "栗子 :chestnut:"
    
    &emsp;&emsp;假设从拨码开关输入操作数A为`8'b1011_0101`（即11.5），输入操作数B为`8'b0010_0111`（即2.7），则：
    
    &emsp;&emsp;计算A + B时，实际应计算11.5 + 2.7 = 14.2，并在数码管高4位显示`16'h0014`，低4位显示`16'h0002`。求绝对值同理。

    &emsp;&emsp;计算A $\times$ 2^B^时，应计算11.5 $\times$ 2^39^。除法同理。

&emsp;&emsp;编写程序时，可先在数据段定义变量，用于提供输入的测试数据以及记录输出的计算结果，并在此基础上完成程序的调试。^^调试完毕后，再将提供输入数据的变量地址改成拨码开关的I/O地址、将保存运算结果的地址改成数码管的I/O地址即可^^。



## 2A. 实验内容 (for miniLA)

### 题目1：基本输入输出

&emsp;&emsp;在提供的miniLA汇编及模拟器环境中，运行提供的程序<font color = blue>**Exercise1A.asm**</font>，并阅读该程序源码，分析程序功能，学习汇编程序访问I/O接口及外设的方法。

&emsp;&emsp;数码管、LED、拨码开关的端口地址同表1-1。

&emsp;&emsp;根据实验步骤运行程序，熟悉汇编及模拟器运行环境的操作流程，并熟悉Logisim工具的操作流程。

### 题目2：简易计算器设计

&emsp;&emsp;题目内容与miniRV的类似，但有以下不同：

&emsp;&emsp;（1）使用miniLA指令集中的指令实现计算器，且 **不要使用你不准备实现的指令**；如果后续设计CPU时不实现附加指令，则编写本题目时，只使用<a href="../1-step_la/#21-loongarch-soc" target=_blank>实验步骤 - 2.1节 - 表2-a</a>所示的25条指令；

&emsp;&emsp;（2）自行新建汇编源文件`calculatorA.asm`，编写计算器程序。



## 3. 实验原理

&emsp;&emsp;线性反馈移位寄存器（LFSR，Linear Feedback Shift Register）是一种采用线性函数生成寄存器新值的移位寄存器，常用于生成随机数。

&emsp;&emsp;LFSR一般由移位寄存器和异或门构成，其典型结构如图1-1所示。在LFSR中，移位寄存器当前值的若干个比特通过异或门形成反馈回路，从而生成LFSR的新值。

<center><img src = "../assets/1-1.png" width = 550></center>
<center>图1-1 LFSR结构原理图</center>

&emsp;&emsp;在图1-1中，**LFSR的初始值称为种子**；而 **a~i~（0$\leq$i$<$n）的值只可能是0或1，表示对应的反馈线路是否生效**。

&emsp;&emsp;对于5位的LFSR，需令a~2~和a~4~等于1，对应的LFSR结构如图1-2所示。

<center><img src = "../assets/1-2.png" width = 500></center>
<center>图1-2 5位的LFSR结构图</center>

&emsp;&emsp;本实验的计算器需要生成32位的随机数，故需要使用汇编程序实现 **32位的LFSR**。此时，**应当令a~0~、a~1~、a~21~和a~31~为1**。实现思路是，首先读取16位的操作数`{A, B}`并生成种子，作为LFSR的初值；然后通过逻辑运算或移位运算，分别取出第0位、第1位、第21位和第31位，再将这4位经过异或后左移进LFSR。
