&emsp;&emsp;控制冒险最简单的解决方法是，在译码阶段检测到当前执行的是分支指令时，采用上一小节中的<a href="../4-handleDH/#21" target="_blank">流水线暂停</a>方法，将分支指令后续的指令暂时冻结，直到分支跳转的方向以及目标地址被确定。此法的优点是其简单性，缺点是造成了流水线性能的损失。

&emsp;&emsp;为了尽可能保持流水线的性能，一种思路是参考乱序执行的做法，在分支指令后方插入若干条无关指令，使得流水线的所有阶段始终处于工作状态，被插入的指令称为分支延迟槽指令；另一种思路是在分支结果产生之前，预测其可能的跳转方向和跳转目标地址，然后提前执行分支目标处的指令。

&emsp;&emsp;分支延迟槽一定程度上降低了汇编程序的可读性。此外，随着流水线深度的增加，延迟槽的实现也变得更加复杂，但其带来的性能提升较为有限。为了简化设计和节省芯片面积，RISC-V ISA没有设置分支延迟槽，而是直接通过分支预测解决控制冒险问题。

## 1. 静态预测方法

&emsp;&emsp;最简单的静态分支预测方法是预测分支指令总是跳转，或预测总是不跳转。显然，使用这种方法对不同的程序进行分支预测时，预测准确率会有很大差异。一种改进的预测方法是若分支指令是往回跳的就预测跳转，否则预测不跳转，这种方法对单循环的预测效果较好。

&emsp;&emsp;静态分支预测的优点是实现简单、硬件开销较小、预测速度较快，但预测准确度相对较低，不能满足通用处理器对性能日益增长的需求。

## 2. 动态预测方法

&emsp;&emsp;动态分支预测根据分支指令的过去表现来预测其将来的行为。如果分支行为发生变化，那么分支预测的结果也相应地发生改变。因此，动态分支预测与静态分支预测相比具有更好的预测准确率和适应性。

### 2.1 基于BHT的分支预测

&emsp;&emsp;基于BHT（Branch History Table）的分支预测方法使用分支历史表来记录分支指令的历史行为。BHT的基础结构如图5-1所示。

<center><img src = "../assets/5-1.png" width = 320></center>
<center>图5-1 基础BHT的结构</center>

&emsp;&emsp;其中，Tag字段类似于Cache的Tag，是指令地址的一部分；分支历史由若干个2bit饱和计数器组成。预测时，取分支指令的地址去查BHT的Tag字段，然后根据BHT当前行的分支历史，对分支的跳转方向进行预测。如果BHT只记录各分支指令最近1次的分支历史，则只需使用1bit的饱和计数器。理论上，可使用任意位宽的饱和计数器来记录分支历史。有研究表明，2bit饱和计数器的预测性能与更高位宽的预测性能差不多。因此在实践中，通常使用2bit饱和计数器。

&emsp;&emsp;基于2bit饱和计数器进行分支预测的原理如图5-2所示。

<center><img src = "../assets/5-2.png" width = 440></center>
<center>图5-2 基于2bit饱和计数器的分支预测</center>

&emsp;&emsp;完整的分支预测过程包含预测和更新2个步骤。预测时，用分支指令的地址查BHT，获得相应的饱和计数器值。若饱和计数器的最高位为1，预测分支跳转，否则预测分支不跳转。当分支指令的实际跳转方向被确定时，不管预测是否正确，都根据图5-2对BHT中的饱和计数器进行更新，从而达到动态调整分支预测结果的目的。

### 2.2 基于全局历史的分支预测

&emsp;&emsp;基于BHT的分支预测方法忽视了分支指令之间的关联性。为此，基于全局历史的分支预测方法在BHT的基础上增加了GHR（Global History Register，全局历史寄存器）来将所有分支指令关联起来。

&emsp;&emsp;基于全局历史的分支预测方法使用一个k比特的GHR来记录所有最近k条分支指令的历史跳转方向，并使用PHT（Pattern History Table，模式历史表）来记录各分支指令的分支历史。其中，PHT的结构类似于BHT。

&emsp;&emsp;预测时，首先将分支指令的地址和GHR进行异或，再用异或操作的结果来查PHT，然后根据PHT当前行的分支历史和分支目标地址，对该分支指令的分支跳转方向和分支目标地址进行预测，如图5-3所示。

<center><img src = "../assets/5-3.png" width = 500></center>
<center>图5-3 基于全局历史的分支预测</center>

&emsp;&emsp;当分支指令的实际跳转行为被确定时，GHR通过移位的方式进行更新——若指令跳转，则GHR = (GHR << 1) | 1，否则GHR = (GHR << 1) | 0。

### 2.3 基于局部历史的分支预测

&emsp;&emsp;基于全局历史的分支预测方法将所有分支指令都关联到一起。然而事实上，并非所有的分支指令都具有关联性。为此，基于局部历史的分支预测方法使用LHT（Local History Table，局部历史表）来代替全局历史预测中的GHR。

&emsp;&emsp;LHT一般具有64条记录，每条记录均包含Tag和局部转移历史2个字段。其中，Tag字段是分支指令地址的一部分，局部转移历史字段则是k比特的移位寄存器，其作用等同于GHR。

&emsp;&emsp;预测时，首先用分支指令的地址查LHT，得到分支指令的局部转移历史LHT[i]；然后将分支指令的地址和LHT[i]进行异或，再用异或操作的结果来查PHT；最后根据PHT当前行的分支历史和分支目标地址，对该分支指令的分支跳转方向和分支目标地址进行预测，如图5-4所示。

<center><img src = "../assets/5-4.png" width = 600></center>
<center>图5-4 基于局部历史的分支预测</center>

&emsp;&emsp;当分支指令的实际跳转行为被确定时，LHT[i]和GHR一样，也通过移位的方式进行更新——若指令跳转，则LHT[i] = (LHT[i] << 1) | 1，否则LHT[i] = (LHT[i] << 1) | 0。

## 3. 分支预测的实现

&emsp;&emsp;CPU执行指令的过程中，检测到当前的指令是分支指令后，对分支结果进行预测，并根据预测结果继续后续的取指操作。需要注意的是，当分支预测失败时，需要清空分支指令之后的流水线中的指令，并修改PC以重新取指。

&emsp;&emsp;添加了分支预测功能的流水线CPU数据通路形如如图5-5所示。

<center><img src = "../assets/5-5.png"></center>
<center>图5-5 支持分支预测的流水线CPU数据通路</center>

&emsp;&emsp;分支指令在执行阶段即可得出分支结果。因此，分支失败时，最多只需清空执行阶段之前的流水级。所谓清空流水级，就是把相应的相应的寄存器清零，如图5-6所示。

``` Verilog linenums="1"
    always @(posedge clk or posedge rst) begin
        if (rst)                 id_pc <= 32'h0;
        else if (flush_pipeline) id_pc <= 32'h0;
        else                     ......
    end

    always @(posedge clk or posedge rst) begin
        if (rst)                 id_inst <= 32'h0;
        else if (flush_pipeline) id_inst <= id_inst;
        else                     ......
    end
    
    ......
```
<center>图5-6 清空IF/ID寄存器的RTL参考实现</center>
