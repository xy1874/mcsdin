&emsp;&emsp;在数字逻辑设计的实验课程中，我们已经学习了如何使用时序仿真来对数字电路进行功能验证。所谓仿真，指的是基于软件模拟 (而非电路实测)的方法来验证电路功能，其基本原理如图7-1所示。

<center><img src = "../assets/7-1.png" width = 550></center>
<center>图7-1 仿真原理</center>

&emsp;&emsp;在图7-1中，我们给待验证电路 (DUT, Design Under Test) 添加一些特定的输入激励，然后观察DUT的输出结果是否符合我们的预期。其中，输入激励和输出结果的检查合称为test bench。

&emsp;&emsp;显然，CPU也是数字电路，当然也可以采用时序仿真的方法对其进行功能验证，但验证效率较低。一方面，CPU的顶层模块通常只包含时钟、复位以及和存储芯片及外设进行交互的信号。仅通过对顶层模块进行验证，验证结果一旦出错，难以定位错误点。因此，只能分模块进行验证，或者借助外设输出相应的调试信息。另一方面，出错点很有可能在通过测试程序的逻辑路径传递很远之后，才能被发现。为了提高验证效率，可以将图7-1中的输入激励从物理信号更换成一段特定的指令序列，并通过观察程序执行结果来验证CPU功能。这种方法虽然大幅提高了验证效率，但无法解决难以定位错误点的问题。

&emsp;&emsp;一种更好的验证方法是使用Trace比对，这也是本课程所使用的方法。所谓Trace，是指CPU执行指令序列时产生的信息 (包括PC和写寄存器的信息等)。

&emsp;&emsp;Trace比对的基本原理如图7-2所示。

<center><img src = "../assets/7-2.png" width = 500></center>
<center>图7-2 Trace比对的基本原理</center>

&emsp;&emsp;使用Trace比对进行CPU功能验证的基本方法是：

&emsp;&emsp;(1) 用已知功能正确的CPU运行测试程序，记录Trace0 (Golden Trace)；

&emsp;&emsp;(2) 用待验证CPU运行相同的测试程序，产生Trace1；

&emsp;&emsp;(3) 将Trace1和Trace0进行实时比对，如果出现不同，立即报错并停止。

!!! hint "补充说明 :bulb:"
    &emsp;&emsp;需要注意的是，Store指令执行时不存在寄存器写操作。这意味着如果Store指令出错，那么Trace比对法并不能立即发现并定位错误点，而只能在后续相关的Load指令出错 (并且一定会出错) 时报错并停止。
